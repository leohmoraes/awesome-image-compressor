{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/child_process/index.js","webpack://exports/./node_modules/@skpm/child_process/lib/exec.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFile.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFileSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/execSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/handleData.js","webpack://exports/./node_modules/@skpm/child_process/lib/normalizeSpawnArguments.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawn.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawnSync.js","webpack://exports/./node_modules/@skpm/events/index.js","webpack://exports/./node_modules/@skpm/timers/test-if-fiber.js","webpack://exports/./node_modules/@skpm/timers/timeout.js","webpack://exports/./node_modules/cocoascript-class/lib/index.js","webpack://exports/./node_modules/cocoascript-class/lib/runtime.js","webpack://exports/./node_modules/sketch-utils/to-array.js","webpack://exports/./src/compress-assets.js","webpack://exports/external \"sketch/ui\""],"names":["execSync","toArray","UI","fileType","png","extension","compressor","pngquant","jpg","jpegoptim","onExportSlices","context","exportRequests","actionContext","exports","compressSlices","targetPaths","filter","currentExport","request","format","map","String","path","replace","length","targetDesc","join","message","pngquantPath","plugin","urlForResourceNamed","jpegoptimPath"],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA,sBAAsB,mBAAO,CAAC,kEAAY;AAC1C,0BAA0B,mBAAO,CAAC,0EAAgB;AAClD,uBAAuB,mBAAO,CAAC,oEAAa;AAC5C,2BAA2B,mBAAO,CAAC,4EAAiB;AACpD,8BAA8B,mBAAO,CAAC,kFAAoB;AAC1D,0BAA0B,mBAAO,CAAC,0EAAgB;;;;;;;;;;;;ACLlD,eAAe,mBAAO,CAAC,sEAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA,4EAAY,mBAAO,CAAC,gEAAS;;AAE7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3LA,gBAAgB,mBAAO,CAAC,wEAAa;;AAErC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yDAAyD;AACzD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC7DA,mBAAmB,mBAAO,CAAC,8EAAgB;;AAE3C;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5EA;AACA,gBAAgB,mBAAO,CAAC,wEAAmB;AAC3C,mBAAmB,mBAAO,CAAC,0DAAc;AACzC,gBAAgB,mBAAO,CAAC,wEAAa;AACrC,iBAAiB,mBAAO,CAAC,0EAAc;AACvC,8BAA8B,mBAAO,CAAC,oGAA2B;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iFAAiF,iBAAiB;AAClG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtNA;AACA,iBAAiB,mBAAO,CAAC,0EAAc;AACvC,8BAA8B,mBAAO,CAAC,oGAA2B;;AAEjE;AACA;;AAEA;AACA;AACA,iFAAiF,iBAAiB;AAClG;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1DA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,sBAAsB;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/PA;AACA;AACA;;;;;;;;;;;;ACFA;AACA,qBAAqB,mBAAO,CAAC,qEAAiB;;AAE9C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yCAAyC,cAAc,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Da;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,eAAe,mBAAO,CAAC,qEAAc;;AAErC;;AAEA;AACA;;AAEA,6EAA6E,YAAY;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;A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","file":"compress-assets.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/compress-assets.js\");\n","module.exports.exec = require('./lib/exec')\nmodule.exports.execFile = require('./lib/execFile')\nmodule.exports.spawn = require('./lib/spawn')\nmodule.exports.spawnSync = require('./lib/spawnSync')\nmodule.exports.execFileSync = require('./lib/execFileSync')\nmodule.exports.execSync = require('./lib/execSync')\n","var execFile = require('./execFile')\n\nfunction normalizeExecArgs(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options);\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command,\n    options: options,\n    callback: callback\n  };\n}\n\nmodule.exports = function(command, options, callback) {\n  var opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n};\n","var spawn = require('./spawn')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout');\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer');\n  }\n}\n\nmodule.exports = function (file, args, options, callback) {\n  var defaultOptions = {\n    encoding: 'utf8',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: undefined,\n    env: undefined,\n    shell: false\n  };\n\n  if (typeof args === 'function') {\n    // function (file, callback)\n    callback = args\n    args = []\n    options = defaultOptions\n  } else if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options, callback)\n    callback = options\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file, args, options, callback)\n    options = Object.assign(defaultOptions, options)\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  var child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell,\n  });\n\n  var encoding;\n  var _stdout;\n  var _stderr;\n  if (options.encoding !== 'buffer' && options.encoding) {\n    encoding = options.encoding;\n    _stdout = '';\n    _stderr = '';\n  } else {\n    _stdout = [];\n    _stderr = [];\n    encoding = null;\n  }\n  var stdoutLen = 0;\n  var stderrLen = 0;\n  var killed = false;\n  var exited = false;\n  var timeoutId;\n\n  var ex = null;\n\n  var cmd = file;\n\n  function exithandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    var stdout;\n    var stderr;\n    if (encoding) {\n      stdout = _stdout;\n      stderr = _stderr;\n    } else {\n      stdout = _stdout.reduce(function (prev, d) {\n        prev.appendData(d)\n        return prev\n      }, NSMutableData.data());\n      stderr = _stderr.reduce(function (prev, d) {\n        prev.appendData(d)\n        return prev\n      }, NSMutableData.data());\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n\n    if (args.length !== 0)\n      cmd += ' ' + args.join(' ');\n\n    if (!ex) {\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr);\n      ex.killed = child.killed || killed;\n      ex.code = code;\n      ex.signal = signal;\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    exithandler();\n  }\n\n  function kill() {\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n\n    child.stdout.on('data', function onChildStdout(chunk) {\n      stdoutLen += encoding ? chunk.length : chunk.length();\n\n      if (stdoutLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stdout');\n        kill();\n      } else if (encoding) {\n        _stdout += chunk;\n      } else {\n        _stdout.push(chunk);\n      }\n    });\n  }\n\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n\n    child.stderr.on('data', function onChildStderr(chunk) {\n      stderrLen += encoding ? chunk.length : chunk.length();\n\n      if (stderrLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stderr');\n        kill();\n      } else if (encoding) {\n        _stderr += chunk;\n      } else {\n        _stderr.push(chunk);\n      }\n    });\n  }\n\n  child.addListener('close', exithandler);\n  child.addListener('error', errorhandler);\n\n  return child;\n}\n","var spawnSync = require('./spawnSync')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout');\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer');\n  }\n}\n\nmodule.exports = function (file, args, options) {\n  var defaultOptions = {\n    encoding: 'utf8',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: null,\n    env: null,\n    shell: false\n  };\n\n  if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options, callback)\n    callback = options\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file, args, options, callback)\n    options = Object.assign(defaultOptions, options || {})\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  var child = spawnSync(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell,\n    encoding: options.encoding\n  });\n\n  if (child.status !== 0) {\n    var error = new Error(\"Failed to run: \" + String(child.stderr))\n    error.pid = child.pid\n    error.status = child.status\n    error.stdout = child.stdout\n    error.stderr = child.stderr\n    throw error\n  }\n\n  return child.stdout;\n}\n","var execFileSync = require('./execFileSync')\n\nfunction normalizeExecArgs(command, options) {\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options);\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command,\n    options: options\n  };\n}\n\nmodule.exports = function(command, options) {\n  var opts = normalizeExecArgs(command, options);\n  return execFileSync(opts.file, opts.options);\n};\n","module.exports = function handleData(data, encoding) {\n  switch (encoding) {\n    case 'utf8':\n      return String(NSString.alloc().initWithData_encoding(data, NSUTF8StringEncoding))\n    case 'ascii':\n      return String(NSString.alloc().initWithData_encoding(data, NSASCIIStringEncoding))\n    case 'utf16le':\n    case 'ucs2':\n      return String(NSString.alloc().initWithData_encoding(data, NSUTF16LittleEndianStringEncoding))\n    case 'base64':\n      var nsdataDecoded = NSData.alloc().initWithBase64EncodedData_options(data, 0)\n      return String(NSString.alloc().initWithData_encoding(nsdataDecoded, NSUTF8StringEncoding))\n    case 'latin1':\n    case 'binary':\n      return String(NSString.alloc().initWithData_encoding(data, NSISOLatin1StringEncoding))\n    case 'hex':\n      // TODO: how?\n      return data\n    default:\n      return data\n  }\n}\n","module.exports = function normalizeSpawnArguments(file, args, options) {\n  if (typeof file !== 'string' || file.length === 0)\n    throw new Error('ERR_INVALID_ARG_TYPE');\n\n  if (Array.isArray(args)) {\n    args = args.slice(0);\n  } else if (args !== undefined && (args === null || typeof args !== 'object')) {\n    throw new Error('ERR_INVALID_ARG_TYPE args');\n  } else {\n    options = args;\n    args = [];\n  }\n\n  if (options === undefined)\n    options = {};\n  else if (options === null || typeof options !== 'object')\n    throw new Error('ERR_INVALID_ARG_TYPE options');\n\n  // Validate the cwd, if present.\n  if (options.cwd != null && typeof options.cwd !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.cwd');\n  }\n\n  // Validate detached, if present.\n  if (options.detached != null && typeof options.detached !== 'boolean') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.detached');\n  }\n\n  // Validate the uid, if present.\n  if (options.uid != null && !Number.isInteger(options.uid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.uid');\n  }\n\n  // Validate the gid, if present.\n  if (options.gid != null && !Number.isInteger(options.gid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.gid');\n  }\n\n  // Validate the shell, if present.\n  if (options.shell != null &&\n      typeof options.shell !== 'boolean' &&\n      typeof options.shell !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.shell');\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null && typeof options.argv0 !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.argv0');\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options);\n\n  if (options.shell) {\n    var command = [file].concat(args).join(' ');\n\n    if (typeof options.shell === 'string') {\n      file = options.shell;\n    } else {\n      file = '/bin/bash';\n    }\n    args = ['-l', '-c', command];\n  }\n\n  if (typeof options.argv0 === 'string') {\n    args.unshift(options.argv0);\n  }\n\n  var env = options.env;\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    envPairs: env\n  };\n}\n","/* globals NSPipe, NSTask, NSArray, NSHomeDirectory, NSFileHandleNotificationDataItem, NSUTF8StringEncoding, NSString, NSNotificationCenter, NSSelectorFromString, NSFileHandleReadCompletionNotification, NSDictionary, NSBundle */\nvar ObjCClass = require('cocoascript-class').default\nvar EventEmitter = require('@skpm/events')\nvar spawnSync = require('./spawnSync')\nvar handleData = require('./handleData')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n// We create one ObjC class for ourselves here\nvar ChildProcess\n\nfunction spawn (_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options);\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync('/bin/bash', ['-l', '-c', 'which ' + opts.file], {encoding: 'utf8'})\n    if (whichChild.err) {\n      var result = new EventEmitter()\n\n      result.stderr = new EventEmitter()\n      result.stdout = new EventEmitter()\n\n      result.stderr.setEncoding = function (encoding) {\n        result.stderr.encoding = encoding\n      }\n      result.stdout.setEncoding = function (encoding) {\n        result.stdout.encoding = encoding\n      }\n      result.emit('error', whichChild.err)\n      return result\n    }\n    return spawn(whichChild.stdout.trim(), _args, _options)\n  } else {\n    var options = opts.options;\n    var result = new EventEmitter()\n\n    result.stderr = new EventEmitter()\n    result.stdout = new EventEmitter()\n\n    result.stderr.setEncoding = function (encoding) {\n      result.stderr.encoding = encoding\n    }\n    result.stdout.setEncoding = function (encoding) {\n      result.stdout.encoding = encoding\n    }\n\n    if (!ChildProcess) {\n      ChildProcess = ObjCClass({\n        classname: 'ChildProcess',\n        listeners: null,\n        fileHandle: null,\n        errFileHandle: null,\n        task: null,\n\n        spawn(args, listeners) {\n          this.listeners = NSDictionary.dictionaryWithDictionary(listeners)\n          var pipe = NSPipe.pipe()\n          var errPipe = NSPipe.pipe()\n\n          this.fileHandle = pipe.fileHandleForReading()\n          this.fileHandle.waitForDataInBackgroundAndNotify()\n\n          this.errFileHandle = pipe.fileHandleForReading()\n          this.errFileHandle.waitForDataInBackgroundAndNotify()\n\n          this.task = NSTask.alloc().init()\n          this.task.setLaunchPath(NSString.stringWithString(opts.file).stringByExpandingTildeInPath())\n          this.task.arguments = NSArray.arrayWithArray(args.args || [])\n          if (args.envPairs) {\n            this.task.environment = args.envPairs\n          }\n          if (args.cwd) {\n            this.task.setCurrentDirectoryPath(NSString.stringWithString(args.cwd).stringByExpandingTildeInPath())\n          }\n\n          this.task.setStandardOutput(pipe)\n          this.task.setStandardError(errPipe)\n\n          this.task.launch()\n        },\n\n        kill() {\n          if (this.task) {\n            this.task.terminate()\n          }\n        },\n\n        'readLine:': function readLine(fileHandle) {\n          var fileDescriptor = fileHandle.object().fileDescriptor()\n          if (fileDescriptor != this.fileHandle.fileDescriptor() &&\n              fileDescriptor != this.errFileHandle.fileDescriptor()) {\n            return\n          }\n          var data = fileHandle.object().availableData()\n          if (!data) {\n            return\n          }\n\n          if (fileDescriptor == this.fileHandle.fileDescriptor()) {\n            this.listeners.onStdout(data)\n            if (this.task) {\n              this.fileHandle.waitForDataInBackgroundAndNotify()\n            }\n          } else if (fileDescriptor == this.errFileHandle.fileDescriptor()) {\n            this.listeners.onStderr(data)\n            if (this.task) {\n              this.errFileHandle.waitForDataInBackgroundAndNotify()\n            }\n          }\n        },\n\n        'taskTerminated:': function taskTerminated(task) {\n          if (task.object().processIdentifier() == this.task.processIdentifier()) {\n            this.listeners.onEnd(Number(this.task.terminationStatus()), null)\n          }\n        }\n      })\n    }\n\n    var child\n\n    try {\n      child = ChildProcess.new();\n    } catch(err) {\n      result.emit('error', err)\n      return result\n    }\n\n    result.killed = false\n    var fiber\n    if (coscript.createFiber) {\n      fiber = coscript.createFiber()\n      fiber.onCleanup(function () {\n        NSNotificationCenter.defaultCenter().removeObserver(child)\n      })\n    } else {\n      coscript.shouldKeepAround = true\n    }\n\n    function cleanupAsync() {\n      if (fiber) {\n        fiber.cleanup()\n      } else {\n        NSNotificationCenter.defaultCenter().removeObserver(child)\n        coscript.shouldKeepAround = false\n      }\n    }\n\n    function onStdout(data) {\n      if (data && data.length()) {\n        result.stdout.emit('data', handleData(data, result.stdout.encoding))\n      }\n    }\n    function onStderr(data) {\n      if (data && data.length()) {\n        result.stderr.emit('data', handleData(data, result.stderr.encoding))\n      }\n    }\n\n    child.spawn({\n      file: opts.file,\n      args: opts.args,\n      cwd: options.cwd,\n      detached: !!options.detached,\n      envPairs: opts.envPairs,\n      stdio: options.stdio,\n      uid: options.uid,\n      gid: options.gid\n    }, {\n      onStdout: onStdout,\n      onStderr: onStderr,\n      onEnd: function (code, signal) {\n        if (!result.killed) {\n          // flush remaining data\n          onStdout(child.fileHandle.readDataToEndOfFile())\n          onStderr(child.errFileHandle.readDataToEndOfFile())\n\n          result.emit('close', code, signal)\n          result.stderr.emit('close')\n          result.stdout.emit('close')\n\n          cleanupAsync()\n        }\n      }\n    })\n\n    NSNotificationCenter.defaultCenter().addObserver_selector_name_object(\n      child,\n      NSSelectorFromString('readLine:'),\n      NSFileHandleDataAvailableNotification,\n      null\n    )\n\n    NSNotificationCenter.defaultCenter().addObserver_selector_name_object(\n      child,\n      NSSelectorFromString('taskTerminated:'),\n      NSTaskDidTerminateNotification,\n      null\n    )\n\n    result.kill = function (signal) {\n      if (!result.killed) {\n        result.killed = true\n        result.emit('close', null, signal)\n        child.kill()\n        cleanupAsync()\n      }\n    }\n\n    result.pid = String(child.task.processIdentifier())\n\n    return result\n  }\n}\n\nmodule.exports = spawn\n","/* globals NSPipe, NSTask, NSArray, NSHomeDirectory, NSFileHandleNotificationDataItem, NSUTF8StringEncoding, NSString, NSNotificationCenter, NSSelectorFromString, NSFileHandleReadCompletionNotification, NSDictionary, NSBundle */\nvar handleData = require('./handleData')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n\nfunction spawnSync (_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options);\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync('/bin/bash', ['-l', '-c', 'which ' + opts.file], {encoding: 'utf8'})\n    if (whichChild.err) {\n      return whichChild\n    }\n    return spawnSync(whichChild.stdout.trim(), _args, _options)\n  } else {\n    var options = opts.options;\n\n    var pipe = NSPipe.pipe()\n    var errPipe = NSPipe.pipe()\n\n    try {\n      var task = NSTask.alloc().init()\n      task.setLaunchPath(NSString.stringWithString(opts.file).stringByExpandingTildeInPath())\n      task.arguments = NSArray.arrayWithArray(opts.args || [])\n      if (opts.envPairs) {\n        task.environment = opts.envPairs\n      }\n\n      if (options.cwd) {\n        task.setCurrentDirectoryPath(NSString.stringWithString(options.cwd).stringByExpandingTildeInPath())\n      }\n\n      task.setStandardOutput(pipe)\n      task.setStandardError(errPipe)\n\n      task.launch()\n      task.waitUntilExit()\n\n      return {\n        pid: String(task.processIdentifier()),\n        status: Number(task.terminationStatus()),\n        get stdout() {\n          var data = pipe.fileHandleForReading().readDataToEndOfFile()\n          return handleData(data, options.encoding)\n        },\n        get stderr() {\n          var data = errPipe.fileHandleForReading().readDataToEndOfFile()\n          return handleData(data, options.encoding)\n        },\n      }\n    } catch (err) {\n      return {\n        err: err,\n      }\n    }\n  }\n}\n\nmodule.exports = spawnSync\n","function EventEmitter () {}\n\n// By default, a maximum of 10 listeners can be registered for any single event.\nEventEmitter.defaultMaxListeners = 10\n\n// Shortcuts to improve speed and size\nvar proto = EventEmitter.prototype\n\nproto._maxListeners = EventEmitter.defaultMaxListeners\n\nfunction indexOfListener (listeners, listener) {\n  var i = listeners.length\n  while (i--) {\n    if (listeners[i].listener === listener) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nfunction alias (name) {\n  return function aliasClosure () {\n    return this[name].apply(this, arguments)\n  }\n}\n\nfunction isValidListener (listener) {\n  if (typeof listener === 'function') {\n    return true\n  } else if (listener && typeof listener === 'object') {\n    return isValidListener(listener.listener)\n  } else {\n    return false\n  }\n}\n\nproto._getListeners = function _getListeners (evt) {\n  var events = this._getEvents()\n\n  return events[evt] || (events[evt] = [])\n}\n\nproto._getEvents = function _getEvents () {\n  return this._events || (this._events = {})\n}\n\n/*\n  Alias for emitter.on(eventName, listener).\n*/\nproto.addListener = alias('on')\n\n/*\n  Synchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\n  Returns true if the event had listeners, false otherwise.\n*/\nproto.emit = function emit (evt) {\n  var args = Array.prototype.slice.call(arguments, 1)\n  var listeners = this._getListeners(evt) || []\n  var listener\n  var i\n  var key\n  var response\n\n  for (i = 0; i < listeners.length; i++) {\n    listener = listeners[i]\n\n    if (listener.once === true) {\n      this.removeListener(evt, listener.listener)\n    }\n\n    response = listener.listener.apply(this, args || [])\n  }\n\n  return listeners.length > 0\n}\n\n/*\n  Returns an array listing the events for which the emitter has registered listeners.\n  The values in the array will be strings or Symbols.\n*/\nproto.eventNames = function eventNames () {\n  var events = this._getEvents()\n  return Object.keys(events)\n}\n\n/*\n  Returns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to EventEmitter.defaultMaxListeners.\n*/\nproto.getMaxListeners = function getMaxListeners() {\n  return this._maxListeners\n}\n\n/*\n  Returns the number of listeners listening to the event named eventName.\n*/\nproto.listenerCount = function listenerCount(eventName) {\n  return this._getListeners(eventName).length\n}\n\n/*\n  Returns a copy of the array of listeners for the event named eventName.\n*/\nproto.listeners = function listeners(eventName) {\n  return this._getListeners(eventName).map(function (wrappedListener) {\n    return wrappedListener.listener\n  })\n}\n\n/*\n  Adds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\n  Returns a reference to the EventEmitter, so that calls can be chained.\n\n  By default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n*/\nproto.on = function on (evt, listener) {\n  if (!isValidListener(listener)) {\n    throw new Error('listener must be a function')\n  }\n\n  var listeners = this._getListeners(evt)\n  var listenerIsWrapped = typeof listener === 'object'\n\n  this.emit('newListener', evt, listenerIsWrapped ? listener.listener : listener)\n\n  listeners.push(\n    listenerIsWrapped\n    ? listener\n    : {\n      listener: listener,\n      once: false\n    }\n  )\n\n  return this\n}\n\n/*\n  Adds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\n  Returns a reference to the EventEmitter, so that calls can be chained.\n\n  By default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n*/\nproto.once = function once (evt, listener) {\n  return this.on(evt, {\n    listener: listener,\n    once: true\n  })\n}\n\n/*\n  Adds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\n  Returns a reference to the EventEmitter, so that calls can be chained.\n*/\nproto.prependListener = function prependListener (evt, listener) {\n  if (!isValidListener(listener)) {\n    throw new Error('listener must be a function')\n  }\n\n  var listeners = this._getListeners(evt)\n  var listenerIsWrapped = typeof listener === 'object'\n\n  this.emit('newListener', evt, listenerIsWrapped ? listener.listener : listener)\n\n  listeners.unshift(\n    listenerIsWrapped\n    ? listener\n    : {\n      listener: listener,\n      once: false\n    }\n  )\n\n  return this\n}\n\n/*\n  Adds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\n  Returns a reference to the EventEmitter, so that calls can be chained.\n*/\nproto.prependOnceListener = function prependOnceListener (evt, listener) {\n  return this.prependListener(evt, {\n    listener: listener,\n    once: true\n  })\n}\n\n/*\n  Removes all listeners, or those of the specified eventName.\n\n  Note that it is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\n  Returns a reference to the EventEmitter, so that calls can be chained.\n*/\nproto.removeAllListeners = function removeAllListeners (evt) {\n  var events = this._getEvents()\n\n  if (typeof evt === 'string') {\n    // Remove all listeners for the specified event\n    delete events[evt]\n  } else {\n    // Remove all listeners in all events\n    delete this._events\n  }\n\n  return this\n}\n\n/*\n  Removes the specified listener from the listener array for the event named eventName.\n\n  removeListener will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener must be called multiple times to remove each instance.\n\n  Note that once an event has been emitted, all listeners attached to it at the time of emitting will be called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events will behave as expected.\n\n  Because listeners are managed using an internal array, calling this will change the position indices of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\n  Returns a reference to the EventEmitter, so that calls can be chained.\n*/\nproto.removeListener = function removeListener (evt, listener) {\n  var listeners = this._getListeners(evt)\n\n  var index = indexOfListener(listeners, listener)\n\n  if (index !== -1) {\n    listeners.splice(index, 1)\n\n    this.emit('removeListener', evt, listener)\n  }\n\n  return this\n}\n\n/*\n  By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. Obviously, not all events should be limited to just 10 listeners. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\n  Returns a reference to the EventEmitter, so that calls can be chained.\n*/\nproto.setMaxListeners = function setMaxListeners (n) {\n  this._maxListeners = n\n  return this\n}\n\n/*\n  Returns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once).\n*/\nproto.rawListeners = function rawListeners (evt) {\n  return this._getListeners(evt).slice()\n}\n\nmodule.exports = EventEmitter\n","module.exports = function () {\n  return typeof coscript !== 'undefined' && coscript.createFiber\n}\n","/* globals coscript, sketch */\nvar fiberAvailable = require('./test-if-fiber')\n\nvar setTimeout\nvar clearTimeout\n\nvar fibers = []\n\nif (fiberAvailable()) {\n  var fibers = []\n\n  setTimeout = function (func, delay, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10) {\n    // fibers takes care of keeping coscript around\n    var id = fibers.length\n    fibers.push(coscript.scheduleWithInterval_jsFunction(\n      (delay || 0) / 1000,\n      function () {\n        func(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)\n      }\n    ))\n    return id\n  }\n\n  clearTimeout = function (id) {\n    var timeout = fibers[id]\n    if (timeout) {\n      timeout.cancel() // fibers takes care of keeping coscript around\n      fibers[id] = undefined // garbage collect the fiber\n    }\n  }\n} else {\n  setTimeout = function (func, delay, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10) {\n    coscript.shouldKeepAround = true\n    var id = fibers.length\n    fibers.push(true)\n    coscript.scheduleWithInterval_jsFunction(\n      (delay || 0) / 1000,\n      function () {\n        if (fibers[id]) { // if not cleared\n          func(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)\n        }\n        clearTimeout(id)\n        if (fibers.every(function (_id) { return !_id })) { // if everything is cleared\n          coscript.shouldKeepAround = false\n        }\n      }\n    )\n    return id\n  }\n\n  clearTimeout = function (id) {\n    fibers[id] = false\n  }\n}\n\nmodule.exports = {\n  setTimeout: setTimeout,\n  clearTimeout: clearTimeout\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = undefined;\nexports.default = ObjCClass;\n\nvar _runtime = require(\"./runtime.js\");\n\nexports.SuperCall = _runtime.SuperCall;\n\n// super when returnType is id and args are void\n// id objc_msgSendSuper(struct objc_super *super, SEL op, void)\n\nconst SuperInit = (0, _runtime.SuperCall)(NSStringFromSelector(\"init\"), [], { type: \"@\" });\n\n// Returns a real ObjC class. No need to use new.\nfunction ObjCClass(defn) {\n  const superclass = defn.superclass || NSObject;\n  const className = (defn.className || defn.classname || \"ObjCClass\") + NSUUID.UUID().UUIDString();\n  const reserved = new Set(['className', 'classname', 'superclass']);\n  var cls = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, superclass);\n  // Add each handler to the class description\n  const ivars = [];\n  for (var key in defn) {\n    const v = defn[key];\n    if (typeof v == 'function' && key !== 'init') {\n      var selector = NSSelectorFromString(key);\n      cls.addInstanceMethodWithSelector_function_(selector, v);\n    } else if (!reserved.has(key)) {\n      ivars.push(key);\n      cls.addInstanceVariableWithName_typeEncoding(key, \"@\");\n    }\n  }\n\n  cls.addInstanceMethodWithSelector_function_(NSSelectorFromString('init'), function () {\n    const self = SuperInit.call(this);\n    ivars.map(name => {\n      Object.defineProperty(self, name, {\n        get() {\n          return getIvar(self, name);\n        },\n        set(v) {\n          (0, _runtime.object_setInstanceVariable)(self, name, v);\n        }\n      });\n      self[name] = defn[name];\n    });\n    // If there is a passsed-in init funciton, call it now.\n    if (typeof defn.init == 'function') defn.init.call(this);\n    return self;\n  });\n\n  return cls.registerClass();\n};\n\nfunction getIvar(obj, name) {\n  const retPtr = MOPointer.new();\n  (0, _runtime.object_getInstanceVariable)(obj, name, retPtr);\n  return retPtr.value().retain().autorelease();\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = SuperCall;\nexports.CFunc = CFunc;\nconst objc_super_typeEncoding = '{objc_super=\"receiver\"@\"super_class\"#}';\n\n// You can store this to call your function. this must be bound to the current instance.\nfunction SuperCall(selector, argTypes, returnType) {\n  const func = CFunc(\"objc_msgSendSuper\", [{ type: '^' + objc_super_typeEncoding }, { type: \":\" }, ...argTypes], returnType);\n  return function (...args) {\n    const struct = make_objc_super(this, this.superclass());\n    const structPtr = MOPointer.alloc().initWithValue_(struct);\n    return func(structPtr, selector, ...args);\n  };\n}\n\n// Recursively create a MOStruct\nfunction makeStruct(def) {\n  if (typeof def !== 'object' || Object.keys(def).length == 0) {\n    return def;\n  }\n  const name = Object.keys(def)[0];\n  const values = def[name];\n\n  const structure = MOStruct.structureWithName_memberNames_runtime(name, Object.keys(values), Mocha.sharedRuntime());\n\n  Object.keys(values).map(member => {\n    structure[member] = makeStruct(values[member]);\n  });\n\n  return structure;\n}\n\nfunction make_objc_super(self, cls) {\n  return makeStruct({\n    objc_super: {\n      receiver: self,\n      super_class: cls\n    }\n  });\n}\n\n// Due to particularities of the JS bridge, we can't call into MOBridgeSupport objects directly\n// But, we can ask key value coding to do the dirty work for us ;)\nfunction setKeys(o, d) {\n  const funcDict = NSMutableDictionary.dictionary();\n  funcDict.o = o;\n  Object.keys(d).map(k => funcDict.setValue_forKeyPath(d[k], \"o.\" + k));\n}\n\n// Use any C function, not just ones with BridgeSupport\nfunction CFunc(name, args, retVal) {\n  function makeArgument(a) {\n    if (!a) return null;\n    const arg = MOBridgeSupportArgument.alloc().init();\n    setKeys(arg, {\n      type64: a.type\n    });\n    return arg;\n  }\n  const func = MOBridgeSupportFunction.alloc().init();\n  setKeys(func, {\n    name: name,\n    arguments: args.map(makeArgument),\n    returnValue: makeArgument(retVal)\n  });\n  return func;\n}\n\n/*\n@encode(char*) = \"*\"\n@encode(id) = \"@\"\n@encode(Class) = \"#\"\n@encode(void*) = \"^v\"\n@encode(CGRect) = \"{CGRect={CGPoint=dd}{CGSize=dd}}\"\n@encode(SEL) = \":\"\n*/\n\nfunction addStructToBridgeSupport(key, structDef) {\n  // OK, so this is probably the nastiest hack in this file.\n  // We go modify MOBridgeSupportController behind its back and use kvc to add our own definition\n  // There isn't another API for this though. So the only other way would be to make a real bridgesupport file.\n  const symbols = MOBridgeSupportController.sharedController().valueForKey('symbols');\n  if (!symbols) throw Error(\"Something has changed within bridge support so we can't add our definitions\");\n  // If someone already added this definition, don't re-register it.\n  if (symbols[key] !== null) return;\n  const def = MOBridgeSupportStruct.alloc().init();\n  setKeys(def, {\n    name: key,\n    type: structDef.type\n  });\n  symbols[key] = def;\n};\n\n// This assumes the ivar is an object type. Return value is pretty useless.\nconst object_getInstanceVariable = exports.object_getInstanceVariable = CFunc(\"object_getInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"^@\" }], { type: \"^{objc_ivar=}\" });\n// Again, ivar is of object type\nconst object_setInstanceVariable = exports.object_setInstanceVariable = CFunc(\"object_setInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"@\" }], { type: \"^{objc_ivar=}\" });\n\n// We need Mocha to understand what an objc_super is so we can use it as a function argument\naddStructToBridgeSupport('objc_super', { type: objc_super_typeEncoding });","module.exports = function toArray(object) {\n  if (Array.isArray(object)) {\n    return object\n  }\n  var arr = []\n  for (var j = 0; j < (object || []).length; j += 1) {\n    arr.push(object[j])\n  }\n  return arr\n}\n","// Awesome Image Compressor, by Naoya Watanabe <hello@showandtell.jp>\n// This plugin compresses PNG and JPG assets using pngquant and jpegoptim right after they're exported from Sketch.\n// \n// [GitHub](https://github.com/naoyawatanabe/awesome-image-compressor)\n// If you have questions, comments or any feedback, file an issue on Github.\n//\n// pngquant © 2009-2018 by Kornel Lesiński.\n// jpegoptim © 1996-2018  Timo Kokkonen <tjko@iki.fi>\n//\n\nconst { execSync } = require('@skpm/child_process')\nconst toArray = require('sketch-utils/to-array')\nconst UI = require('sketch/ui')\n\nconst fileType = {\n  png: {\n    extension: 'png',\n    compressor: pngquant()\n  },\n  jpg: {\n    extension: 'jpg',\n    compressor: jpegoptim()\n  }\n}\n\nexport function onExportSlices(context) {\n  const exportRequests = toArray(context.actionContext.exports)\n  compressSlices(exportRequests, fileType.png)\n  compressSlices(exportRequests, fileType.jpg)\n}\n\nfunction compressSlices(exportRequests, fileType) {\n  const targetPaths = exportRequests\n    .filter(currentExport => currentExport.request.format() == fileType.extension)\n    .map(currentExport => String(currentExport.path))\n    .map(currentExport => String(currentExport.replace(/\\\\/g, '\\\\\\\\')))\n\n  if (targetPaths.length === 0) {\n    return\n  }\n\n  const targetDesc = `${targetPaths.length} ${fileType.extension} file${ targetPaths.length == 1 ? '' : 's' }`\n\n  execSync(`${fileType.compressor} \"${targetPaths.join('\" \"')}\"`)\n  UI.message(`Compressed ${targetDesc}`)\n}\n\nfunction pngquant() {\n  const pngquantPath = context.plugin.urlForResourceNamed('node_modules/pngquant-bin/vendor/pngquant').path()\n  return pngquantPath.replace(/ /g, '\\\\ ') + ' --ext .png -f'\n}\n\nfunction jpegoptim() {\n  const jpegoptimPath = context.plugin.urlForResourceNamed('node_modules/jpegoptim-bin/vendor/jpegoptim').path()\n  return jpegoptimPath.replace(/ /g, '\\\\ ') + ' --max=80'\n}","module.exports = require(\"sketch/ui\");"],"sourceRoot":""}